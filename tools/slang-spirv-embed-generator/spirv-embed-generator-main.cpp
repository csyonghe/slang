#include <cstdio>

#include "source/core/slang-io.h"
#include "source/compiler-core/slang-diagnostic-sink.h"
#include "source/compiler-core/slang-perfect-hash.h"
#include "source/core/slang-writer.h"
#include "source/compiler-core/slang-spirv-core-grammar.h"
#include "source/compiler-core/slang-lexer.h"

using namespace Slang;

template<typename T, typename F>
String dictToPerfectHash(
    const Dictionary<UnownedStringSlice, T>& dict,
    const UnownedStringSlice& type,
    F valueToString)
{
    HashParams hashParams;
    List<String> names;
    for(const auto& [name, val] : dict)
        names.add(name);
    auto r = minimalPerfectHash(names, hashParams);
    SLANG_ASSERT(r == HashFindResult::Success);
    List<String> values;
    values.reserve(hashParams.destTable.getCount());
    for(const auto& v : hashParams.destTable)
    {
        values.add(valueToString(dict.getValue(v.getUnownedSlice())));
    }
    return perfectHashToEmbeddableCpp(hashParams, type, values);
}

template<typename K, typename V, typename F1, typename F2>
void dictToSwitch(
    const Dictionary<K, V>& dict,
    const char* funName,
    const char* keyType,
    const char* valueType,
    const F1 keyToString,
    const F2 valueToAssignmentString,
    WriterHelper& w)
{
    const auto line = [&](const auto& l){
        w.put(l);
        w.put("\n");
    };

    w.print("static bool %s(const %s& k, %s& v)\n", funName, keyType, valueType);
    line("{");
    line("    switch(k)");
    line("    {");
    for(const auto& [k, v] : dict)
    {
        const auto kStr = keyToString(k);
        const auto vStr = valueToAssignmentString(v);
        w.print(
            "        case %s:\n"
            "        {\n"
            "            %s;\n"
            "            return true;\n"
            "        }\n",
            kStr.getBuffer(),
            vStr.getBuffer()
        );
    }
    line("        default: return false;");
    line("    }");
    line("}");
    line("");
}

void writeInfo(
    const char* const outCppPath,
    const SPIRVCoreGrammarInfo& info)
{
    StringBuilder sb;
    StringWriter writer(&sb, WriterFlags(0));
    WriterHelper w(&writer);
    const auto line = [&](const auto& l){
        w.put(l);
        w.put("\n");
    };

    //
    line("// Source embedding for SPIR-V core grammar");
    line("//");
    line("// This file was carefully generated by a machine,");
    line("// don't even think about modifying it yourself!");
    line("//");
    line("");
    line("#include \"../core/slang-smart-pointer.h\"");
    line("#include \"../compiler-core/slang-spirv-core-grammar.h\"");

    //
    line("namespace Slang");
    line("{");

    w.put("static ");
    w.put(dictToPerfectHash(
        info.opcodes.dict,
        UnownedStringSlice("SpvOp"),
        [](const auto n){
            const auto radix = 10;
            return "static_cast<SpvOp>(" + String(n, radix) + ")";
        }
    ).getBuffer());

    w.put("static ");
    w.put(dictToPerfectHash(
        info.capabilities.dict,
        UnownedStringSlice("SpvCapability"),
        [](const auto n){
            const auto radix = 10;
            return "static_cast<SpvCapability>(" + String(n, radix) + ")";
        }
    ).getBuffer());

    w.put("static ");
    w.put(dictToPerfectHash(
        info.allEnums.dict,
        UnownedStringSlice("SpvWord"),
        [](const auto n){
            const auto radix = 10;
            return "SpvWord{" + String(n, radix) + "}";
        }
    ).getBuffer());

    line("using OperandKind = SPIRVCoreGrammarInfo::OperandKind;");
    dictToSwitch(
        info.opInfos.dict,
        "getOpInfo",
        "SpvOp",
        "SPIRVCoreGrammarInfo::OpInfo",
        [&](SpvOp o){
            return "Spv" + String(info.opNames.dict.getValue(o));
        },
        [](const Slang::SPIRVCoreGrammarInfo::OpInfo& i){
            const char* classStr;
            switch(i.class_)
            {
                case SPIRVCoreGrammarInfo::OpInfo::Other: classStr = "Other"; break;
                case SPIRVCoreGrammarInfo::OpInfo::TypeDeclaration: classStr = "TypeDeclaration"; break;
                case SPIRVCoreGrammarInfo::OpInfo::ConstantCreation: classStr = "ConstantCreation"; break;
            }

            String ret = String("const static OperandKind operandTypes[] = {");
            String operandTypes;
            for(Index o = 0; o < i.numOperandTypes; ++o)
            {
                if(o != 0)
                    ret.append(", ");
                ret.append("{" + String(i.operandTypes[o].index) + "}");
            }
            ret.append(
                "};\n            "
                + String("v = {SPIRVCoreGrammarInfo::OpInfo::")
                + classStr + ", "
                + String(i.resultTypeIndex) + ", "
                + String(i.resultIdIndex) + ", "
                + String(i.minWordCount) + ", "
                + (i.maxWordCount == 0xffff ? String("0xffff") : String(i.maxWordCount)) + ", "
                + String(i.numOperandTypes) + ", "
                + "operandTypes"
                + "}");
            return ret;
        },
        w
    );

    dictToSwitch(
        info.opNames.dict,
        "getOpName",
        "SpvOp",
        "UnownedStringSlice",
        [&](SpvOp o){
            return "Spv" + String(info.opNames.dict.getValue(o));
        },
        [](const UnownedStringSlice& i){
            return "v = UnownedStringSlice{\"" + String(i) + "\"}";
        },
        w
    );

    w.put("static ");
    w.put(dictToPerfectHash(
        info.operandKinds.dict,
        UnownedStringSlice("OperandKind"),
        [](const auto n){
            const auto radix = 10;
            return "OperandKind{" + String(n.index, radix) + "}";
        }
    ).getBuffer());

    line("RefPtr<SPIRVCoreGrammarInfo> SPIRVCoreGrammarInfo::getEmbeddedVersion()");
    line("{");
    line("    static SPIRVCoreGrammarInfo embedded = [](){");
    line("        SPIRVCoreGrammarInfo info;");
    line("        info.opcodes.embedded = &lookupSpvOp;");
    line("        info.capabilities.embedded = &lookupSpvCapability;");
    line("        info.allEnums.embedded = &lookupSpvWord;");
    line("        info.opInfos.embedded = &getOpInfo;");
    line("        info.opNames.embedded = &getOpName;");
    line("        info.operandKinds.embedded = &lookupOperandKind;");

    //
    line("        info.addReference();");
    line("        return info;");
    line("    }();");
    line("    return &embedded;");
    line("}");
    line("}");

    File::writeAllTextIfChanged(outCppPath, sb.getUnownedSlice());
}

int main(int argc, const char* const* argv)
{
    using namespace Slang;

    if (argc != 3)
    {
        fprintf(
            stderr,
            "Usage: %s spirv.core.grammar.json output.cpp\n",
            argc >= 1 ? argv[0] : "slang-spirv-embed-generator");
        return 1;
    }

    const char* const inPath = argv[1];
    const char* const outCppPath = argv[2];

    RefPtr<FileWriter> writer(new FileWriter(stderr, WriterFlag::AutoFlush));
    SourceManager      sourceManager;
    sourceManager.initialize(nullptr, nullptr);
    DiagnosticSink sink(&sourceManager, Lexer::sourceLocationLexer);
    sink.writer = writer;

    String contents;
    SLANG_RETURN_ON_FAIL(File::readAllText(inPath, contents));
    PathInfo    pathInfo = PathInfo::makeFromString(inPath);
    SourceFile* sourceFile = sourceManager.createSourceFileWithString(pathInfo, contents);
    SourceView* sourceView = sourceManager.createSourceView(sourceFile, nullptr, SourceLoc());

    RefPtr<SPIRVCoreGrammarInfo> info = SPIRVCoreGrammarInfo::loadFromJSON(*sourceView, sink);

    writeInfo(outCppPath, *info);

    return 0;
}
