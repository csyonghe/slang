#include <cstdio>

#include "source/core/slang-io.h"
#include "source/compiler-core/slang-diagnostic-sink.h"
#include "source/compiler-core/slang-perfect-hash.h"
#include "source/core/slang-writer.h"
#include "source/compiler-core/slang-spirv-core-grammar.h"
#include "source/compiler-core/slang-lexer.h"

using namespace Slang;

template<typename T>
String dictToPerfectHash(
    const Dictionary<UnownedStringSlice, T>& dict,
    const UnownedStringSlice& type,
    const bool isMask)
{
    HashParams<String> hashParams;
    List<String> names;
    for(const auto& [name, val] : dict)
        names.add(name);
    auto r = minimalPerfectHash(names, hashParams);
    SLANG_ASSERT(r == HashFindResult::Success);
    hashParams.valueTable.reserve(hashParams.destTable.getCount());
    const auto radix = isMask ? 16 : 10;
    const auto prefix = isMask ? "0x" : "";
    for(const auto& v : hashParams.destTable)
    {
        const auto s = prefix + String(dict.getValue(v.getUnownedSlice()), radix);
        hashParams.valueTable.add("static_cast<" + String(type) + ">(" + s + ")");
    }
    return perfectHashToEmbeddableCpp(hashParams, type);
}

void writeInfo(
    const char* const outCppPath,
    const SPIRVCoreGrammarInfo& info)
{
    StringBuilder sb;
    StringWriter writer(&sb, WriterFlags(0));
    WriterHelper w(&writer);
    const auto line = [&](const auto& l){
        w.put(l);
        w.put("\n");
    };

    //
    line("// Source embedding for SPIR-V core grammar");
    line("//");
    line("// This file was carefully generated by a machine,");
    line("// don't even think about modifying it yourself!");
    line("//");
    line("");
    line("#include \"../core/slang-smart-pointer.h\"");
    line("#include \"../compiler-core/slang-spirv-core-grammar.h\"");

    //
    line("namespace Slang");
    line("{");

    w.put(dictToPerfectHash(
        info.spvOps.dict,
        UnownedStringSlice("SpvOp"),
        false
    ).getBuffer());

    w.put(dictToPerfectHash(
        info.spvCapabilities.dict,
        UnownedStringSlice("SpvCapability"),
        false
    ).getBuffer());

    w.put(dictToPerfectHash(
        info.anyEnum.dict,
        UnownedStringSlice("SpvWord"),
        false
    ).getBuffer());

    line("static bool getOpInfo(const SpvOp& op, SPIRVCoreGrammarInfo::OpInfo& info)");
    line("{");
    line("    switch(op)");
    line("    {");
    for(const auto [o, i] : info.opInfo.dict)
    {
        const char* classStr;
        switch(i.class_)
        {
            case SPIRVCoreGrammarInfo::OpInfo::Other: classStr = "Other"; break;
            case SPIRVCoreGrammarInfo::OpInfo::TypeDeclaration: classStr = "TypeDeclaration"; break;
            case SPIRVCoreGrammarInfo::OpInfo::ConstantCreation: classStr = "ConstantCreation"; break;
        }
        w.print(
            "        case %d: info = {SPIRVCoreGrammarInfo::OpInfo::%s, %d, %d}; return true;\n",
            o,
            classStr,
            i.resultTypeIndex,
            i.resultIdIndex
        );
    }
    line("        default: return false;");
    line("    }");
    line("}");
    line("");

    line("RefPtr<SPIRVCoreGrammarInfo> SPIRVCoreGrammarInfo::getEmbeddedVersion()");
    line("{");
    line("    static SPIRVCoreGrammarInfo embedded = [](){");
    line("        SPIRVCoreGrammarInfo info;");
    line("        info.spvOps.embedded = &lookupSpvOp;");
    line("        info.spvCapabilities.embedded = &lookupSpvCapability;");
    line("        info.anyEnum.embedded = &lookupSpvWord;");
    line("        info.opInfo.embedded = &getOpInfo;");

    //
    line("        info.addReference();");
    line("        return info;");
    line("    }();");
    line("    return &embedded;");
    line("}");
    line("}");

    File::writeAllTextIfChanged(outCppPath, sb.getUnownedSlice());
}

int main(int argc, const char* const* argv)
{
    using namespace Slang;

    if (argc != 3)
    {
        fprintf(
            stderr,
            "Usage: %s spirv.core.grammar.json output.cpp\n",
            argc >= 1 ? argv[0] : "slang-spirv-embed-generator");
        return 1;
    }

    const char* const inPath = argv[1];
    const char* const outCppPath = argv[2];

    RefPtr<FileWriter> writer(new FileWriter(stderr, WriterFlag::AutoFlush));
    SourceManager      sourceManager;
    sourceManager.initialize(nullptr, nullptr);
    DiagnosticSink sink(&sourceManager, Lexer::sourceLocationLexer);
    sink.writer = writer;

    String contents;
    SLANG_RETURN_ON_FAIL(File::readAllText(inPath, contents));
    PathInfo    pathInfo = PathInfo::makeFromString(inPath);
    SourceFile* sourceFile = sourceManager.createSourceFileWithString(pathInfo, contents);
    SourceView* sourceView = sourceManager.createSourceView(sourceFile, nullptr, SourceLoc());

    RefPtr<SPIRVCoreGrammarInfo> info = SPIRVCoreGrammarInfo::loadFromJSON(*sourceView, sink);

    writeInfo(outCppPath, *info);

    return 0;
}
